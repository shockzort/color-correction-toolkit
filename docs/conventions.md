# Соглашение о разработке

## Проект CudaWorker

### 1. Общие принципы

#### 1.1 Domain-Driven Design (DDD)

Проект следует принципам DDD для обеспечения чистой архитектуры и разделения ответственности:

- **Доменная модель** - центральная часть приложения, содержащая бизнес-логику
- **Слоистая архитектура** - четкое разделение слоев приложения
- **Инкапсуляция** - сокрытие внутренней реализации за интерфейсами
- **Ubiquitous Language** - единый язык домена во всем проекте

### 2. Структура проекта

#### 2.1 Организация кода

``` bash
modules/
├── shared/                 # Общие типы и утилиты
│   ├── types/              # Общие типы
│   ├── utils/              # Утилитарные функции
├── {module_name}/          # Код конкретного модуля
│   ├── interface/          # Интерфейс модуля
│   ├── internal/           # Внутренняя реализация
│   ├── config/             # Конфигурационные файлы
|   |── changelog.d         # Ченжлоги
│   └── VERSION             # Версия модуля
└── tools/                  # Инструменты разработки
```

#### 2.2 Слои архитектуры (DDD)

##### Domain Layer (Доменный слой)

- Entities - доменные сущности
- Value Objects - объекты-значения
- Domain Services - доменные сервисы
- Repository Interfaces - интерфейсы репозиториев
- Domain Events - доменные события

##### Application Layer (Слой приложения)

- Use Cases - сценарии использования
- Application Services - сервисы приложения
- DTOs - объекты передачи данных
- Command/Query Handlers - обработчики команд и запросов

##### Infrastructure Layer (Инфраструктурный слой)

- Repository Implementations - реализации репозиториев
- Database Access - доступ к БД
- External Services - внешние сервисы
- Message Brokers - брокеры сообщений

##### API Layer (API слой)

- gRPC Handlers - обработчики gRPC
- HTTP Handlers - обработчики HTTP
- Middleware - промежуточное ПО
- Request/Response Models - модели запросов/ответов

### 3. Соглашения по коду

#### 3.1 Именование

##### Modules (Модули)

- Используйте `PascalCase` для имен модулей
- Имена должны быть краткими и описательными
- Избегайте сокращений без крайней необходимости

##### Types (Типы)

- `PascalCase` для экспортируемых типов
- `camelCase` для не экспортируемых типов
- Интерфейсы должны описывать поведение (`Reader`, `Writer`, `Storage`)

##### Functions/Methods (Функции/Методы)

- `PascalCase` для экспортируемых функций
- `camelCase` для не экспортируемых функций
- Имена должны начинаться с глагола

##### Variables (Переменные)

- `camelCase` для переменных
- Краткие имена для локальных переменных (`ctx`, `err`, `id`)
- Описательные имена для полей структур

##### Constants (Константы)

- `UPPER_SNAKE_CASE` для констант пакетного уровня
- `CamelCase` для констант в структурах

#### 3.2 Комментарии и документация

##### Комментарии к типам

```cpp
    TODO:
```

##### Комментарии к функциям

```cpp
    TODO:
```

#### 3.3 Обработка ошибок

##### Создание ошибок

```cpp
    TODO:
```

##### Проверка типов ошибок

```cpp
    TODO:
```

### 4. Паттерны и практики

#### 4.1 Паттерны

- При разработке следует руководствоваться паттерном DRY для снижения избыточности кода.
- Рекомендуется максимально переиспользовать код, если это не нарушает принципов ООП и SOLID. При этом следует руководствоваться паттерном KISS (Keep It Simple, Stupid) для снижения сложности кода.
- При разработке следует формировать тестовое покрытие всех разрабатываемых модулей.

#### 4.2 Практики

- Используйте clang-format для форматирования кода.
- Используйте логгирование для фиксации основных ошибок и событий.
- Комментируйте код только там, где это необходимо - для объяснения идей, не дублируя код.
- Используйте константы вместо магических чисел.

### 5. Технические соглашения

#### 5.1 Конфигурация

- Используйте TOML для конфигурационных файлов
- Валидация конфигурации при запуске

#### 5.2 Логирование

```cpp
    TODO:

// Структурированное логирование

// Логирование ошибок

```

#### 5.3 Тестирование

```cpp
    TODO:
```
