# Тестирование

Ниже представлены требования и рекомендации к тестированию кода проекта.

## Юнит-тесты

Как известно, юнит-тестирование подразумевает тестирование кода как такового и без внешних зависимостей (баз данных, запускаемых исполняемых программ и пр.).

Если для целей тестирования требуются внешние зависимости (например, запуск ffmpeg для тестов), такие тесты следует расценивать как интеграционные (см. ниже).

Юнит-тесты могут быть двух видов.

### Тестирование по принципу "черного ящика"

Все внутренние приватные методы/атрибуты тестируемых пакетов и его сущностей являются недоступными для тестирующего кода.
Соответственно, код теста не должен, на сколько это возможно, знать и полагаться на внутренние особенности и поведение тестируемого кода.

Тестированию подлежит только публичный API.

На практике, полностью скрыть поведение кода не всегда возможно, т.к. тестируемый код может зависеть от публичных интерфейсов, вызов методов которых является сайд-эффектом работы кода.
Например, вызов метода некоторого тестируемого сервиса должен сохранить данные в хранилище, вызвав в свою очередь некоторый известный метод интерфейса этого хранилища.
Часто, зависимостями в тестах выступают сгенерированные моки интерфейсов и в тестах проверяется корректность вызова их методов.

Само по себе, тестирование через проверку сайд-эффектов (например, на основе моков) противоречит идее "черного ящика", т.к. может раскрывать детали внутреннего взаимодействия компонентов между собой.
В целом, для тестирования публичного API важен итоговый наблюдаемый результат, а не порядок вызовов моковых методов или иных сайд-эффектов.

Однако для целей тестирования может быть целесообразно и удобно использовать моковые имплементации интерфейсов, т.к. это позволяет упростить подготовку сцены тестирования, внедрения зависимостей в тестируемую сущность и пр.

Поэтому, допускается использовать моки и, при необходимости, полагаться на сайд-эффекты их вызовов.
В таких тестах вызов методов моков становится частью работы черного ящика и контракта тестируемого кода.

При этом, не следует чрезмерно сильно завязывать тесты на проверку моковых вызовов, т.к. такие тесты становятся ломкими, а изменение интерфейсов не всегда означает какие-то поведенческие изменения в тестируемом коде.
Например, если сервис вызывает моковый метод хранилища, в сигнатуре которого есть аргументы несущественные для поведения тестируемого API, такие аргументы можно игнорировать и не проверять с точностью до полей структур.

Тесты "черного ящика" должны располагаться в пакете тестируемого кода в файлах с именем `*_test.cpp`. Допускается создавать более одного файла с тестами одной сущности, если это требуется для повышения читаемости или логического разделения тестов.

Для тестов "черного ящика" должен быть указан пакет с суффиксом `{module_name}_test` тестируемого пакета.

### Тестирование по принципу "белого ящика"

В тестах белого ящика допускается использовать приватный API, атрибуты и методы тестируемых сущностей.

Обычно, такие тесты нужны именно для тестирования корректного поведения сущности. Т.е. проверяется корректность поведенческих характеристик публичного API, которые нельзя достоверно проверить методом "черного ящика".
Например, graceful shutdown, отсутствие гонок и пр.

Тесты "белого ящика" должны располагаться в пакете тестируемого кода в файлах с именем `*_internal_test.go`.

Имя пакета тестов "белого ящика" должны соответствовать имени тестируемого пакета.

## Интеграционные тесты

При интеграционном тестировании, код тестируется в связке с внешними зависимостями (базами данных, сервисами, сторонними исполняемыми программами и т.д.), API которых подразумевается использовать при реальной эксплуатации.
Предметом тестирования выступает корректность работы кода при использовании внешних сервисов.

Например, внешней зависимостью может быть локально запущенная база данных или эмулятор стороннего сервиса API которого используется кодом.

Этот вид тестирования не накладывает ограничения на характеристики используемых внешних сервисов. Например, такие тесты не проверяют нагрузочные характеристики как сервиса, так и кода.

В отличие от юнит-тестов, интеграционные тесты должны запускаться в заранее корректном подготовленном окружении.
Поэтому запуск интеграционных тестов должен быть отделен от юнит-тестов. Но при этом допускается одновременный запуск интеграционных и юнит-тестов, для сокращения времени проведения тестирования.

Интеграционные тесты должны быть написаны по принципу тестирования "черного ящика", поэтому для них справедливы требования описанные выше.

Интеграционные тесты могут располагаться в пакетах тестируемого кода в файлах с именем `*_test.go`.

Имена интеграционных тестов должны начинаться с префикса `Test_Integration_`. Это позволит запускать интеграционные тесты отдельно от юнит-тестов.

После префикса могут быть указаны дополнительные ключевые слова, которые позволят отделить одни интеграционные тесты от других.

Интеграционные тесты должны быть "пропускаемыми", чтобы позволит не запускать их по умолчанию.

## Параллельный запуск тестов

Рекомендуется маркировать тесты и суб-тесты для параллельного запуска, если это технически возможно (например, если в тестах нет конкуренции за один общий ресурс в базы данных и пр.)/

## Запуск тестов

### Запуск тестов

Для запуска тестов, выполнить команду:

``` make
make test
```

Для запуска только юнит-тестов:

``` make
make test-unit
```

## Makefile

Запуск тестов должен быть отражен в основном `Makefile` проекта с учетом специфики тестирования и конфигурациями подключения к внешним сервисам.
